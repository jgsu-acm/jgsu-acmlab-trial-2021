%!TEX program = xelatex
\documentclass[
	lang=cn,
	color=blue
]{elegantbook}
\usepackage{tabularx,booktabs} 
\usepackage{listings}
\usepackage{xr}
\usepackage{hyperref}
\externaldocument{../problem/problem}

\newcolumntype{M}{>{\centering\arraybackslash}X}

\lstset{
    language=C++,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{brown}\ttfamily,
    commentstyle=\color{teal}\ttfamily,
    morecomment=[l][\color{brown}]{\#}
}

\hypersetup{
    colorlinks=true,
	urlcolor=blue
}

\begin{document}

\begin{titlepage}
    \begin{center}
        \LARGE
        \textbf{ACM算法与微应用开发实验室21届成员选拔赛题解} \par
        \normalsize
        \vspace{0.5cm}
        2021年11月6日
    \end{center}

    \section*{题目概览}
    \begin{center}
        \begin{tabularx}{\textwidth}{M|M|M|M}
            \toprule
            \textbf{题目编号} & \textbf{题目名称} & \textbf{出题人} & \textbf{做法} \\
            \midrule
            A                 & \ref*{pro:1}      & \ref*{aut:1}    & 线性筛        \\
            B                 & \ref*{pro:2}      & \ref*{aut:2}    & 搜索          \\
            C                 & \ref*{pro:3}      & \ref*{aut:3}    & 贪心          \\
            D                 & \ref*{pro:4}      & \ref*{aut:4}    & 前缀和        \\
            E                 & \ref*{pro:5}      & \ref*{aut:5}    & 模拟          \\
            F                 & \ref*{pro:6}      & \ref*{aut:6}    & 模拟          \\
            \bottomrule
        \end{tabularx}
    \end{center}

    \paragraph*{} 注意：因篇幅显示，部分标程省略了头文件部分。
    \paragraph*{} 所有标程代码均可以在\url{https://github.com/jgsu-acm/jgsu-acmlab-trial-2021}找到。

    \section*{鸣谢}
    感谢Tifa大佬为本次比赛贡献的题目。

\end{titlepage}

\chapter*{A.\quad \ref*{pro:1}}
\section*{做法}

本题考查对线性筛算法的理解。

我们回想一下线性筛在干什么，首先我们有一个 \verb|visit| 数组用来存我们是否已经筛过当前的数，还有个 \verb|prime| 数组记录我们筛出的素数。

我们从2开始遍历，如果当前的数没被筛掉，那它就是素数。同时对于我们枚举的每个数 $i$，我们把 $i$ 与素数 $p_j$ 的乘积筛掉，也就是在 visit 数组打上标记，$p_j$ 要满足 $p_j<p$, 其中 $p$ 是 $i$ 的最小素因子，这样能确保每个数都会被不重不漏地访问一遍。

那我们怎么找 $k-$素数呢？

我们再定义一个数组 \verb|k_cnt[]|, \verb|k_cnt[i]| 表示 i 能表示为多少个素数的乘积。显然，对所有的素数 $p$, \verb|k_cnt[p]| 都应赋为 1。并且 \verb|k_cnt[i * p] = k_cnt[i] + 1|

所以我们只需要在标记 $i\times p_j$ 时把 \verb|k_cnt[i * prime[j]]| 赋为 \verb|k_cnt[i] + 1| 即可

完全 $k-$素数同理

\section*{标程}

\chapter*{B.\quad \ref*{pro:2}}
\section*{做法}

\section*{标程}

\chapter*{C.\quad \ref*{pro:3}}
\section*{做法}

\section*{标程}

\chapter*{D.\quad \ref*{pro:4}}
\section*{做法}
\paragraph*{暴力做法} 对于每次询问都使用循环来统计区间内数字和的方法的时间复杂度为$O(mn)$，对于本题$1e5$的数据规模显然不能通过。

\paragraph*{正解} 需要使用一种叫做“前缀和”的简单算法。

注意到$$a_l+a_{l+1}+ \cdots + a_r = (a_1 + a_2 + \cdots + a_r) - (a_1 + a_2 + \cdots + a_{l-1})$$

我们定义$$pre_i = a_1 + a_2 + \cdots + a_i$$

于是$$a_l+a_{l+1}+ \cdots + a_r = pre_r - pre_{l-1}$$

所以对于每次$[l,r]$查询，只需要$O(1)$的时间复杂度即可得出结果，而$pre_i$可以通过$pre_i = pre_{i-1} + a_i$的递推式从而在$O(n)$的时间复杂度内推出来。总时间复杂度为$O(n+m)$。

\section*{标程}
\begin{lstlisting}
#include <iostream>
using namespace std;
const int maxn = 1e5+5;
int pre[maxn];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)       // O(n)处理出pre (pre[i]=pre[i-1]+a[i])
    {
        int x;
        cin>>x;
        pre[i]=pre[i-1]+x;
    }
    while(m--)                  // O(m)处理所有询问
    {
        int l,r;
        cin>>l>>r;
        cout<<pre[r]-pre[l-1]<<endl;
    }
}
\end{lstlisting}

\chapter*{E.\quad \ref*{pro:5}}
\section*{做法}

一个模拟题，写法很多。这里给出其中一种

我们考虑枚举出雀头，删去雀头的两张牌后判断剩余的12张牌是否为4个面子。

我们可以直接对每种牌模3，之后判断剩下的牌是不是顺子即可

\section*{标程}

\chapter*{F.\quad \ref*{pro:6}}
\section*{做法}
签到题，题意即求出$\lfloor A \times (1-p1\%) \times (85\%)^0 \rfloor + \lfloor A \times (1-p2\%) \times (85\%)^1 \rfloor + \lfloor A \times (1-p3\%) \times (85\%)^2 \rfloor + \lfloor A \times (1-p4\%) \times (85\%)^3 \rfloor$的值。可以使用秦九韶算法，也可以\lstinline{cout}一行搞定。

\section*{标程}
\lstinline{cout}一行搞定：
\begin{lstlisting}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int A,p1,p2,p3,p4;
        cin>>A>>p1>>p2>>p3>>p4;
        cout<<((int)(A*(1-p1/100.0)) + (int)(A * 0.85 * (1-p2/100.0)) + (int)(A * 0.85 * 0.85 * (1-p3/100.0)) + (int)(A * 0.85 * 0.85 * 0.85 * (1-p4/100.0)))<<endl;
    }
    return 0;
}
\end{lstlisting}

秦九韶算法：
\begin{lstlisting}
int p[7];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int A;
        cin>>A;
        for(int i=1;i<=4;i++) cin>>p[i];
        double mul = 1;
        int sum = 0;
        for(int i=1;i<=4;i++, mul *= 0.85)
            sum += (int)(A * mul * (1 - p[i] / 100.0));
        cout<<sum<<endl;
    }
    return 0;
}
\end{lstlisting}

\end{document}